from launch import LaunchDescription
from launch_ros.actions import Node
from launch.actions import DeclareLaunchArgument
from launch.substitutions import LaunchConfiguration
from ament_index_python.packages import get_package_share_directory
import os


def generate_launch_description():
    return LaunchDescription([
        # Launch arguments for TCP connections
        DeclareLaunchArgument(
            'lidar_tcp_ip',
            default_value='127.0.0.1',
            description='IP address of the LiDAR TCP server'
        ),
        DeclareLaunchArgument(
            'lidar_tcp_port',
            default_value='12350',  # Matches C++ LIDAR_SEND_PORT in TCP_Connection.h
            description='Port number of the LiDAR TCP server'
        ),
        
        # Visualization parameters
        DeclareLaunchArgument(
            'point_size',
            default_value='2.0',
            description='Size of individual point markers'
        ),
        DeclareLaunchArgument(
            'center_size',
            default_value='3.0',
            description='Size of cluster center markers'
        ),
        DeclareLaunchArgument(
            'cube_alpha',
            default_value='0.3',
            description='Transparency for cube visualizations (0-1)'
        ),
        DeclareLaunchArgument(
            'verbose_logging',
            default_value='true',  # Enable verbose logging for detailed processing info
            description='Enable verbose logging'
        ),
        
        # CARLA LiDAR configuration parameters - optimized for road perception and wall detection
        DeclareLaunchArgument(
            'lidar_channels',
            default_value='32',
            description='Number of vertical channels in the LiDAR'
        ),
        DeclareLaunchArgument(
            'lidar_points_per_second',
            default_value='120000',
            description='Points per second generated by the LiDAR'
        ),
        DeclareLaunchArgument(
            'lidar_rotation_frequency',
            default_value='20.0',  # Optimized rotation frequency for detailed scanning
            description='Rotation frequency of the LiDAR in Hz'
        ),
        DeclareLaunchArgument(
            'lidar_range',
            default_value='70.0',  # Updated to match C++ reference value (70m)
            description='Maximum detection range of the LiDAR in meters'
        ),
        DeclareLaunchArgument(
            'lidar_upper_fov',
            default_value='0.0',   # FOV optimized for detecting walls and tall structures
            description='Upper vertical field of view in degrees'
        ),
        DeclareLaunchArgument(
            'lidar_lower_fov',
            default_value='-10.0',  # Updated to match C++ reference value (-10Â°)
            description='Lower vertical field of view in degrees'
        ),
        DeclareLaunchArgument(
            'lidar_height',
            default_value='2.0',   # Height matching the vehicle mounting position
            description='Height of the LiDAR from ground level in meters'
        ),
        
        # LiDAR processing parameters - match the C++ implementation exactly
        DeclareLaunchArgument(
            'sor_std_dev_mult',
            default_value='7.0',   # Higher multiplier to preserve detail including potential outliers
            description='Statistical Outlier Removal standard deviation multiplier'
        ),
        DeclareLaunchArgument(
            'voxel_grid_size',
            default_value='0.1',   # Small voxel size for close-range object detail
            description='Voxel grid filter size in meters'
        ),
        DeclareLaunchArgument(
            'ransac_iterations',
            default_value='200',   # Higher iterations for reliable ground plane detection
            description='RANSAC ground plane detection iterations'
        ),
        DeclareLaunchArgument(
            'ransac_distance_threshold',
            default_value='0.22',  # Threshold for precise ground vs. object separation
            description='RANSAC distance threshold in meters'
        ),
        DeclareLaunchArgument(
            'cluster_tolerance',
            default_value='0.35',  # Tolerance for distinct object separation
            description='Euclidean clustering distance tolerance in meters'
        ),
        DeclareLaunchArgument(
            'min_cluster_size',
            default_value='2',     # Very low minimum to detect small/partial objects
            description='Minimum number of points per cluster'
        ),
        DeclareLaunchArgument(
            'max_cluster_size',
            default_value='10000', # High maximum for large structures like walls
            description='Maximum number of points per cluster'
        ),
        
        # Vehicle mounting position parameters
        DeclareLaunchArgument(
            'lidar_forward_offset',
            default_value='1.5',   # LiDAR mounted 1.5m forward from vehicle center
            description='LiDAR forward offset from vehicle center in meters'
        ),
        DeclareLaunchArgument(
            'lidar_lateral_offset',
            default_value='0.0',   # LiDAR centered laterally
            description='LiDAR lateral offset from vehicle center in meters (positive is right)'
        ),
        
        # TCP buffer sizes to match C++ implementation
        DeclareLaunchArgument(
            'tcp_buffer_size',
            default_value='1048576',  # Matches 1MB buffer size in TCP_Connection.cpp
            description='TCP receive buffer size in bytes'
        ),
        
        # LiDAR Simple Listener Node
        Node(
            package='sensor_fusion',
            executable='lidar_listener_simple',
            name='lidar_simple_visualizer',
            parameters=[{
                'tcp_ip': LaunchConfiguration('lidar_tcp_ip'),
                'tcp_port': LaunchConfiguration('lidar_tcp_port'),
                'point_size': LaunchConfiguration('point_size'),
                'center_size': LaunchConfiguration('center_size'),
                'cube_alpha': LaunchConfiguration('cube_alpha'),
                'verbose_logging': LaunchConfiguration('verbose_logging'),
                
                # CARLA LiDAR configuration
                'lidar_channels': LaunchConfiguration('lidar_channels'),
                'lidar_points_per_second': LaunchConfiguration('lidar_points_per_second'),
                'lidar_rotation_frequency': LaunchConfiguration('lidar_rotation_frequency'),
                'lidar_range': LaunchConfiguration('lidar_range'),
                'lidar_upper_fov': LaunchConfiguration('lidar_upper_fov'),
                'lidar_lower_fov': LaunchConfiguration('lidar_lower_fov'),
                'lidar_height': LaunchConfiguration('lidar_height'),
                
                # Processing parameters
                'sor_std_dev_mult': LaunchConfiguration('sor_std_dev_mult'),
                'voxel_grid_size': LaunchConfiguration('voxel_grid_size'),
                'ransac_iterations': LaunchConfiguration('ransac_iterations'),
                'ransac_distance_threshold': LaunchConfiguration('ransac_distance_threshold'),
                'cluster_tolerance': LaunchConfiguration('cluster_tolerance'),
                'min_cluster_size': LaunchConfiguration('min_cluster_size'),
                'max_cluster_size': LaunchConfiguration('max_cluster_size'),
                
                # Vehicle mounting position
                'lidar_forward_offset': LaunchConfiguration('lidar_forward_offset'),
                'lidar_lateral_offset': LaunchConfiguration('lidar_lateral_offset'),
                
                # TCP configuration
                'tcp_buffer_size': LaunchConfiguration('tcp_buffer_size'),
                
                # Cluster classification thresholds to match C++ code
                'tiny_cluster_threshold': 3,       # Matches TINY_CLUSTER_THRESHOLD in C++ (2-3 points)
                'small_cluster_threshold': 6,      # Matches SMALL_CLUSTER_THRESHOLD in C++ (4-6 points)
                'medium_cluster_threshold': 15,    # Matches MEDIUM_CLUSTER_THRESHOLD in C++ (7-15 points)
                
                # Enable special detection features
                'detect_road_features': True,      # Enable detection of road-level features (curbs, etc.)
                'detect_vertical_features': True,  # Enable detection of vertical features (walls, poles)
                'preserve_small_clusters': True,   # Prioritize preservation of small clusters
                
                # Additional processing parameters
                'vertical_feature_min_height': 0.5,  # Matches zRange threshold in C++ code
                'road_feature_max_height': 0.3,      # Matches minZ threshold in C++ code
            }],
            output='screen'
        ),
        
        # RViz for visualization
        Node(
            package='rviz2',
            executable='rviz2',
            name='rviz2',
            arguments=['-d', [get_package_share_directory('sensor_fusion'), '/rviz/sensor_fusion.rviz']],
            output='screen'
        ),
        
        # TF static transform publishers
        Node(
            package='tf2_ros',
            executable='static_transform_publisher',
            name='tf_world_to_map',
            arguments=['0', '0', '0', '0', '0', '0', 'world', 'map'],
            output='screen'
        ),
        
        # TF for LiDAR mounting position relative to vehicle
        Node(
            package='tf2_ros',
            executable='static_transform_publisher',
            name='tf_vehicle_to_lidar',
            arguments=[
                LaunchConfiguration('lidar_forward_offset'), 
                LaunchConfiguration('lidar_lateral_offset'), 
                LaunchConfiguration('lidar_height'), 
                '0', '0', '0', 
                'vehicle', 'lidar'
            ],
            output='screen'
        ),
    ]) 